{"ast":null,"code":"var _jsxFileName = \"D:\\\\CODE\\\\solidity\\\\hardhat\\u5165\\u95E8\\\\hardhat-react-1\\\\my-app\\\\src\\\\components\\\\Dapp.js\";\nimport React from 'react';\nimport { ethers } from 'ethers';\nimport simpleTokenArtifact from '../contracts/SimpleToken.json';\nimport contractAddress from '../contracts/contract-address.json';\nimport deployerAccount from '../contracts/deployer.json';\nimport { NoWalletDetected } from './NoWalletDetected';\nimport { ConnectWallet } from './ConnectWallet';\nimport { Loading } from './Loading';\nimport { Transfer } from './Transfer';\nimport { TransactionErrorMessage } from './TransactionErrorMessage';\nimport { WaitingForTransactionMessage } from './WaitingForTransactionMessage';\nimport { NoTokensMessage } from './NoTokensMessage';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst HARDHAT_NETWORK_ID = '31337';\nconst ERROR_CODE_TX_REJECTED_BY_USER = 4001;\nlet simpleTokenContractAddress = contractAddress.contractAddress;\nconst contractDeployer = deployerAccount.deployer;\nexport class Dapp extends React.Component {\n  constructor(props) {\n    super(props);\n\n    // We store multiple things in Dapp's state.\n    // You don't need to follow this pattern, but it's an useful example.\n    this.initialState = {\n      // The info of the token (i.e. It's Name and symbol)\n      tokenData: undefined,\n      // The user's address and balance\n      selectedAddress: undefined,\n      balance: undefined,\n      // The ID about transactions being sent, and any possible error with them\n      txBeingSent: undefined,\n      deployBegin: undefined,\n      transactionError: undefined,\n      networkError: undefined,\n      decimals: undefined\n    };\n    this.state = this.initialState;\n  }\n  render() {\n    // Ethereum wallets inject the window.ethereum object. If it hasn't been\n    // injected, we instruct the user to install MetaMask.\n    if (window.ethereum === undefined) {\n      return /*#__PURE__*/_jsxDEV(NoWalletDetected, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 54,\n        columnNumber: 14\n      }, this);\n    }\n\n    // The next thing we need to do, is to ask the user to connect their wallet.\n    // When the wallet gets connected, we are going to save the users's address\n    // in the component's state. So, if it hasn't been saved yet, we have\n    // to show the ConnectWallet component.\n    //\n    // Note that we pass it a callback that is going to be called when the user\n    // clicks a button. This callback just calls the _connectWallet method.\n    if (!this.state.selectedAddress) {\n      return /*#__PURE__*/_jsxDEV(ConnectWallet, {\n        connectWallet: () => this._connectWallet(),\n        networkError: this.state.networkError,\n        dismiss: () => this._dismissNetworkError()\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 66,\n        columnNumber: 9\n      }, this);\n    }\n\n    // If the token data or the user's balance hasn't loaded yet, we show\n    // a loading component.\n    if (!this.state.tokenData || !this.state.balance) {\n      return /*#__PURE__*/_jsxDEV(Loading, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 77,\n        columnNumber: 14\n      }, this);\n    }\n\n    // If everything is loaded, we render the application.\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"container p-4\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"row\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"col-12\",\n          children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n            children: [this.state.tokenData.name, \" (\", this.state.tokenData.symbol, \")\"]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 85,\n            columnNumber: 13\n          }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n            children: [\"Welcome \", /*#__PURE__*/_jsxDEV(\"b\", {\n              children: this.state.selectedAddress\n            }, void 0, false, {\n              fileName: _jsxFileName,\n              lineNumber: 89,\n              columnNumber: 23\n            }, this), \", you have\", ' ', /*#__PURE__*/_jsxDEV(\"b\", {\n              children: [ethers.utils.formatUnits(this.state.balance, this.state.decimals), \" \", this.state.tokenData.symbol]\n            }, void 0, true, {\n              fileName: _jsxFileName,\n              lineNumber: 90,\n              columnNumber: 15\n            }, this), \".\"]\n          }, void 0, true, {\n            fileName: _jsxFileName,\n            lineNumber: 88,\n            columnNumber: 13\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 84,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 83,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"hr\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 99,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"row\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"col-12\",\n          children: [this.state.txBeingSent && /*#__PURE__*/_jsxDEV(WaitingForTransactionMessage, {\n            txHash: this.state.txBeingSent\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 109,\n            columnNumber: 15\n          }, this), this.state.transactionError && /*#__PURE__*/_jsxDEV(TransactionErrorMessage, {\n            message: this._getRpcErrorMessage(this.state.transactionError),\n            dismiss: () => this._dismissTransactionError()\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 117,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 102,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 101,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"row\",\n        children: /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"col-12\",\n          children: [this.state.balance.eq(0) && /*#__PURE__*/_jsxDEV(NoTokensMessage, {\n            deployContract: () => this._deployContract()\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 131,\n            columnNumber: 15\n          }, this), this.state.deployBegin && /*#__PURE__*/_jsxDEV(Loading, {}, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 133,\n            columnNumber: 40\n          }, this), this.state.balance.gt(0) && /*#__PURE__*/_jsxDEV(Transfer, {\n            transferTokens: (to, amount) =>\n            // convert to contract precise amount\n            this._transferTokens(to, ethers.utils.parseUnits(amount, this.state.decimals))\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 142,\n            columnNumber: 15\n          }, this)]\n        }, void 0, true, {\n          fileName: _jsxFileName,\n          lineNumber: 126,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 125,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 82,\n      columnNumber: 7\n    }, this);\n  }\n  componentWillUnmount() {\n    // We poll the user's balance, so we have to stop doing that when Dapp\n    // gets unmounted\n    this._stopPollingData();\n  }\n  async _connectWallet() {\n    // This method is run when the user clicks the Connect. It connects the\n    // dapp to the user's wallet, and initializes it.\n\n    // To connect to the user's wallet, we have to run this method.\n    // It returns a promise that will resolve to the user's address.\n    const [selectedAddress] = await window.ethereum.request({\n      method: 'eth_requestAccounts'\n    });\n\n    // Once we have the address, we can initialize the application.\n\n    // First we check the network\n    if (!this._checkNetwork()) {\n      return;\n    }\n    this._initialize(selectedAddress);\n\n    // We reinitialize it whenever the user changes their account.\n    window.ethereum.on('accountsChanged', ([newAddress]) => {\n      this._stopPollingData();\n      // `accountsChanged` event can be triggered with an undefined newAddress.\n      // This happens when the user removes the Dapp from the \"Connected\n      // list of sites allowed access to your addresses\" (Metamask > Settings > Connections)\n      // To avoid errors, we reset the dapp state\n      if (newAddress === undefined) {\n        return this._resetState();\n      }\n      this._initialize(newAddress);\n    });\n\n    // We reset the dapp state if the network is changed\n    window.ethereum.on('chainChanged', ([_chainId]) => {\n      this._stopPollingData();\n      this._resetState();\n    });\n  }\n  _initialize(userAddress) {\n    // This method initializes the dapp\n\n    // We first store the user's address in the component's state\n    this.setState({\n      selectedAddress: userAddress\n    });\n\n    // Then, we initialize ethers, fetch the token's data, and start polling\n    // for the user's balance.\n\n    // Fetching the token data and the user's balance are specific to this\n    // sample project, but you can reuse the same initialization pattern.\n    this._intializeEthers();\n    this._getTokenData();\n    this._startPollingData();\n  }\n  async _intializeEthers() {\n    // We first initialize ethers by creating a provider using window.ethereum\n    this._provider = new ethers.providers.Web3Provider(window.ethereum);\n\n    // When, we initialize the contract using that provider and the token's\n    // artifact. You can do this same thing with your contracts.\n    this._simpleToken = new ethers.Contract(simpleTokenContractAddress, simpleTokenArtifact.abi, this._provider.getSigner(0));\n    this.setState({\n      decimals: await this._simpleToken.decimals()\n    });\n  }\n\n  // The next to methods are needed to start and stop polling data. While\n  // the data being polled here is specific to this example, you can use this\n  // pattern to read any data from your contracts.\n  //\n  // Note that if you don't need it to update in near real time, you probably\n  // don't need to poll it. If that's the case, you can just fetch it when you\n  // initialize the app, as we do with the token data.\n  _startPollingData() {\n    this._pollDataInterval = setInterval(() => this._updateBalance(), 1000);\n\n    // We run it once immediately so we don't have to wait for it\n    this._updateBalance();\n  }\n  _stopPollingData() {\n    clearInterval(this._pollDataInterval);\n    this._pollDataInterval = undefined;\n  }\n\n  // The next two methods just read from the contract and store the results\n  // in the component state.\n  async _getTokenData() {\n    const name = await this._simpleToken.name();\n    const symbol = await this._simpleToken.symbol();\n    this.setState({\n      tokenData: {\n        name,\n        symbol\n      }\n    });\n  }\n  async _updateBalance() {\n    const balance = await this._simpleToken.balanceOf(this.state.selectedAddress);\n    this.setState({\n      balance\n    });\n  }\n\n  // This method sends an ethereum transaction to transfer tokens.\n  // While this action is specific to this application, it illustrates how to\n  // send a transaction.\n  async _transferTokens(to, amount) {\n    // Sending a transaction is a complex operation:\n    //   - The user can reject it\n    //   - It can fail before reaching the ethereum network (i.e. if the user\n    //     doesn't have ETH for paying for the tx's gas)\n    //   - It has to be mined, so it isn't immediately confirmed.\n    //     Note that some testing networks, like Hardhat Network, do mine\n    //     transactions immediately, but your dapp should be prepared for\n    //     other networks.\n    //   - It can fail once mined.\n    //\n    // This method handles all of those things, so keep reading to learn how to\n    // do it.\n\n    try {\n      // If a transaction fails, we save that error in the component's state.\n      // We only save one such error, so before sending a second transaction, we\n      // clear it.\n      this._dismissTransactionError();\n\n      // We send the transaction, and save its hash in the Dapp's state. This\n      // way we can indicate that we are waiting for it to be mined.\n      const tx = await this._simpleToken.transfer(to, amount);\n      this.setState({\n        txBeingSent: tx.hash\n      });\n\n      // We use .wait() to wait for the transaction to be mined. This method\n      // returns the transaction's receipt.\n      const receipt = await tx.wait();\n\n      // The receipt, contains a status flag, which is 0 to indicate an error.\n      if (receipt.status === 0) {\n        // We can't know the exact error that make the transaction fail once it\n        // was mined, so we throw this generic one.\n        throw new Error('Transaction failed');\n      }\n\n      // If we got here, the transaction was successful, so you may want to\n      // update your state. Here, we update the user's balance.\n      await this._updateBalance();\n    } catch (error) {\n      // We check the error code to see if this error was produced because the\n      // user rejected a tx. If that's the case, we do nothing.\n      if (error.code === ERROR_CODE_TX_REJECTED_BY_USER) {\n        return;\n      }\n\n      // Other errors are logged and stored in the Dapp's state. This is used to\n      // show them to the user, and for debugging.\n      console.error(error);\n      this.setState({\n        transactionError: error\n      });\n    } finally {\n      // If we leave the try/catch, we aren't sending a tx anymore, so we clear\n      // this part of the state.\n      this.setState({\n        txBeingSent: undefined\n      });\n    }\n  }\n\n  // This method just clears part of the state.\n  _dismissTransactionError() {\n    this.setState({\n      transactionError: undefined\n    });\n  }\n\n  // This method just clears part of the state.\n  _dismissNetworkError() {\n    this.setState({\n      networkError: undefined\n    });\n  }\n\n  // This is an utility method that turns an RPC error into a human readable\n  // message.\n  _getRpcErrorMessage(error) {\n    if (error.data) {\n      return error.data.message;\n    }\n    return error.message;\n  }\n\n  // This method resets the state\n  _resetState() {\n    this.setState(this.initialState);\n  }\n\n  // This method checks if Metamask selected network is Localhost:8545\n  _checkNetwork() {\n    if (window.ethereum.networkVersion === HARDHAT_NETWORK_ID) {\n      return true;\n    }\n    this.setState({\n      networkError: 'Please connect Metamask to goerli'\n    });\n    return false;\n  }\n  async _deployContract() {\n    this.setState({\n      deployBegin: true\n    });\n    let simpleTokenContractFactory = new ethers.ContractFactory(simpleTokenArtifact.abi, simpleTokenArtifact.bytecode, this._provider.getSigner(0));\n    let simpleTokenContract = await simpleTokenContractFactory.deploy('hello', 'Dapp', 1, 100000000);\n    await simpleTokenContract.deployed();\n    simpleTokenContractAddress = simpleTokenContract.address;\n    await this._intializeEthers();\n    this.setState({\n      deployBegin: undefined\n    });\n  }\n}","map":{"version":3,"names":["React","ethers","simpleTokenArtifact","contractAddress","deployerAccount","NoWalletDetected","ConnectWallet","Loading","Transfer","TransactionErrorMessage","WaitingForTransactionMessage","NoTokensMessage","jsxDEV","_jsxDEV","HARDHAT_NETWORK_ID","ERROR_CODE_TX_REJECTED_BY_USER","simpleTokenContractAddress","contractDeployer","deployer","Dapp","Component","constructor","props","initialState","tokenData","undefined","selectedAddress","balance","txBeingSent","deployBegin","transactionError","networkError","decimals","state","render","window","ethereum","fileName","_jsxFileName","lineNumber","columnNumber","connectWallet","_connectWallet","dismiss","_dismissNetworkError","className","children","name","symbol","utils","formatUnits","txHash","message","_getRpcErrorMessage","_dismissTransactionError","eq","deployContract","_deployContract","gt","transferTokens","to","amount","_transferTokens","parseUnits","componentWillUnmount","_stopPollingData","request","method","_checkNetwork","_initialize","on","newAddress","_resetState","_chainId","userAddress","setState","_intializeEthers","_getTokenData","_startPollingData","_provider","providers","Web3Provider","_simpleToken","Contract","abi","getSigner","_pollDataInterval","setInterval","_updateBalance","clearInterval","balanceOf","tx","transfer","hash","receipt","wait","status","Error","error","code","console","data","networkVersion","simpleTokenContractFactory","ContractFactory","bytecode","simpleTokenContract","deploy","deployed","address"],"sources":["D:/CODE/solidity/hardhat入门/hardhat-react-1/my-app/src/components/Dapp.js"],"sourcesContent":["import React from 'react'\r\n\r\nimport { ethers } from 'ethers'\r\n\r\n\r\nimport simpleTokenArtifact from '../contracts/SimpleToken.json'\r\nimport contractAddress from '../contracts/contract-address.json'\r\nimport deployerAccount from '../contracts/deployer.json'\r\n\r\n\r\nimport { NoWalletDetected } from './NoWalletDetected'\r\nimport { ConnectWallet } from './ConnectWallet'\r\nimport { Loading } from './Loading'\r\nimport { Transfer } from './Transfer'\r\nimport { TransactionErrorMessage } from './TransactionErrorMessage'\r\nimport { WaitingForTransactionMessage } from './WaitingForTransactionMessage'\r\nimport { NoTokensMessage } from './NoTokensMessage'\r\n\r\nconst HARDHAT_NETWORK_ID = '31337'\r\n\r\nconst ERROR_CODE_TX_REJECTED_BY_USER = 4001\r\n\r\nlet simpleTokenContractAddress = contractAddress.contractAddress\r\n\r\nconst contractDeployer = deployerAccount.deployer\r\n\r\nexport class Dapp extends React.Component {\r\n  constructor(props) {\r\n    super(props)\r\n\r\n    // We store multiple things in Dapp's state.\r\n    // You don't need to follow this pattern, but it's an useful example.\r\n    this.initialState = {\r\n      // The info of the token (i.e. It's Name and symbol)\r\n      tokenData: undefined,\r\n      // The user's address and balance\r\n      selectedAddress: undefined,\r\n      balance: undefined,\r\n      // The ID about transactions being sent, and any possible error with them\r\n      txBeingSent: undefined,\r\n      deployBegin: undefined,\r\n      transactionError: undefined,\r\n      networkError: undefined,\r\n      decimals: undefined,\r\n    }\r\n\r\n    this.state = this.initialState\r\n  }\r\n\r\n  render() {\r\n    // Ethereum wallets inject the window.ethereum object. If it hasn't been\r\n    // injected, we instruct the user to install MetaMask.\r\n    if (window.ethereum === undefined) {\r\n      return <NoWalletDetected />\r\n    }\r\n\r\n    // The next thing we need to do, is to ask the user to connect their wallet.\r\n    // When the wallet gets connected, we are going to save the users's address\r\n    // in the component's state. So, if it hasn't been saved yet, we have\r\n    // to show the ConnectWallet component.\r\n    //\r\n    // Note that we pass it a callback that is going to be called when the user\r\n    // clicks a button. This callback just calls the _connectWallet method.\r\n    if (!this.state.selectedAddress) {\r\n      return (\r\n        <ConnectWallet\r\n          connectWallet={() => this._connectWallet()}\r\n          networkError={this.state.networkError}\r\n          dismiss={() => this._dismissNetworkError()}\r\n        />\r\n      )\r\n    }\r\n\r\n    // If the token data or the user's balance hasn't loaded yet, we show\r\n    // a loading component.\r\n    if (!this.state.tokenData || !this.state.balance) {\r\n      return <Loading />\r\n    }\r\n\r\n    // If everything is loaded, we render the application.\r\n    return (\r\n      <div className=\"container p-4\">\r\n        <div className=\"row\">\r\n          <div className=\"col-12\">\r\n            <h1>\r\n              {this.state.tokenData.name} ({this.state.tokenData.symbol})\r\n            </h1>\r\n            <p>\r\n              Welcome <b>{this.state.selectedAddress}</b>, you have{' '}\r\n              <b>\r\n                {/* show human read balance (deployed contract with precise 1 in /scripts/deploy.js) */}\r\n                {ethers.utils.formatUnits(this.state.balance, this.state.decimals)} {this.state.tokenData.symbol}\r\n              </b>\r\n              .\r\n            </p>\r\n          </div>\r\n        </div>\r\n\r\n        <hr />\r\n\r\n        <div className=\"row\">\r\n          <div className=\"col-12\">\r\n            {/* \r\n              Sending a transaction isn't an immidiate action. You have to wait\r\n              for it to be mined.\r\n              If we are waiting for one, we show a message here.\r\n            */}\r\n            {this.state.txBeingSent && (\r\n              <WaitingForTransactionMessage txHash={this.state.txBeingSent} />\r\n            )}\r\n\r\n            {/* \r\n              Sending a transaction can fail in multiple ways. \r\n              If that happened, we show a message here.\r\n            */}\r\n            {this.state.transactionError && (\r\n              <TransactionErrorMessage\r\n                message={this._getRpcErrorMessage(this.state.transactionError)}\r\n                dismiss={() => this._dismissTransactionError()}\r\n              />\r\n            )}\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"row\">\r\n          <div className=\"col-12\">\r\n            {/*\r\n              If the user has no tokens, we don't show the Tranfer form\r\n            */}\r\n            {this.state.balance.eq(0) && (\r\n              <NoTokensMessage deployContract={() => this._deployContract()} />\r\n            )}\r\n            {this.state.deployBegin && <Loading />}\r\n\r\n            {/*\r\n              This component displays a form that the user can use to send a \r\n              transaction and transfer some tokens.\r\n              The component doesn't have logic, it just calls the transferTokens\r\n              callback.\r\n            */}\r\n            {this.state.balance.gt(0) && (\r\n              <Transfer\r\n                transferTokens={(to, amount) =>\r\n                  // convert to contract precise amount\r\n                  this._transferTokens(to, ethers.utils.parseUnits(amount, this.state.decimals))\r\n                }\r\n              />\r\n            )}\r\n          </div>\r\n        </div>\r\n      </div>\r\n    )\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    // We poll the user's balance, so we have to stop doing that when Dapp\r\n    // gets unmounted\r\n    this._stopPollingData()\r\n  }\r\n\r\n  async _connectWallet() {\r\n    // This method is run when the user clicks the Connect. It connects the\r\n    // dapp to the user's wallet, and initializes it.\r\n\r\n    // To connect to the user's wallet, we have to run this method.\r\n    // It returns a promise that will resolve to the user's address.\r\n    const [selectedAddress] = await window.ethereum.request({ method: 'eth_requestAccounts' });\r\n\r\n    // Once we have the address, we can initialize the application.\r\n\r\n    // First we check the network\r\n    if (!this._checkNetwork()) {\r\n      return\r\n    }\r\n\r\n    this._initialize(selectedAddress)\r\n\r\n    // We reinitialize it whenever the user changes their account.\r\n    window.ethereum.on('accountsChanged', ([newAddress]) => {\r\n      this._stopPollingData()\r\n      // `accountsChanged` event can be triggered with an undefined newAddress.\r\n      // This happens when the user removes the Dapp from the \"Connected\r\n      // list of sites allowed access to your addresses\" (Metamask > Settings > Connections)\r\n      // To avoid errors, we reset the dapp state\r\n      if (newAddress === undefined) {\r\n        return this._resetState()\r\n      }\r\n\r\n      this._initialize(newAddress)\r\n    })\r\n\r\n    // We reset the dapp state if the network is changed\r\n    window.ethereum.on('chainChanged', ([_chainId]) => {\r\n      this._stopPollingData()\r\n      this._resetState()\r\n    })\r\n  }\r\n\r\n  _initialize(userAddress) {\r\n    // This method initializes the dapp\r\n\r\n    // We first store the user's address in the component's state\r\n    this.setState({\r\n      selectedAddress: userAddress,\r\n    })\r\n\r\n    // Then, we initialize ethers, fetch the token's data, and start polling\r\n    // for the user's balance.\r\n\r\n    // Fetching the token data and the user's balance are specific to this\r\n    // sample project, but you can reuse the same initialization pattern.\r\n    this._intializeEthers()\r\n    this._getTokenData()\r\n    this._startPollingData()\r\n  }\r\n\r\n  async _intializeEthers() {\r\n    // We first initialize ethers by creating a provider using window.ethereum\r\n    this._provider = new ethers.providers.Web3Provider(window.ethereum)\r\n\r\n    // When, we initialize the contract using that provider and the token's\r\n    // artifact. You can do this same thing with your contracts.\r\n    this._simpleToken = new ethers.Contract(\r\n      simpleTokenContractAddress,\r\n      simpleTokenArtifact.abi,\r\n      this._provider.getSigner(0)\r\n    )\r\n    this.setState({decimals: await this._simpleToken.decimals()})\r\n  }\r\n\r\n  // The next to methods are needed to start and stop polling data. While\r\n  // the data being polled here is specific to this example, you can use this\r\n  // pattern to read any data from your contracts.\r\n  //\r\n  // Note that if you don't need it to update in near real time, you probably\r\n  // don't need to poll it. If that's the case, you can just fetch it when you\r\n  // initialize the app, as we do with the token data.\r\n  _startPollingData() {\r\n    this._pollDataInterval = setInterval(() => this._updateBalance(), 1000)\r\n\r\n    // We run it once immediately so we don't have to wait for it\r\n    this._updateBalance()\r\n  }\r\n\r\n  _stopPollingData() {\r\n    clearInterval(this._pollDataInterval)\r\n    this._pollDataInterval = undefined\r\n  }\r\n\r\n  // The next two methods just read from the contract and store the results\r\n  // in the component state.\r\n  async _getTokenData() {\r\n    const name = await this._simpleToken.name()\r\n    const symbol = await this._simpleToken.symbol()\r\n\r\n    this.setState({ tokenData: { name, symbol } })\r\n  }\r\n\r\n  async _updateBalance() {\r\n    const balance = await this._simpleToken.balanceOf(\r\n      this.state.selectedAddress\r\n    )\r\n    this.setState({ balance })\r\n  }\r\n\r\n  // This method sends an ethereum transaction to transfer tokens.\r\n  // While this action is specific to this application, it illustrates how to\r\n  // send a transaction.\r\n  async _transferTokens(to, amount) {\r\n    // Sending a transaction is a complex operation:\r\n    //   - The user can reject it\r\n    //   - It can fail before reaching the ethereum network (i.e. if the user\r\n    //     doesn't have ETH for paying for the tx's gas)\r\n    //   - It has to be mined, so it isn't immediately confirmed.\r\n    //     Note that some testing networks, like Hardhat Network, do mine\r\n    //     transactions immediately, but your dapp should be prepared for\r\n    //     other networks.\r\n    //   - It can fail once mined.\r\n    //\r\n    // This method handles all of those things, so keep reading to learn how to\r\n    // do it.\r\n\r\n    try {\r\n      // If a transaction fails, we save that error in the component's state.\r\n      // We only save one such error, so before sending a second transaction, we\r\n      // clear it.\r\n      this._dismissTransactionError()\r\n\r\n      // We send the transaction, and save its hash in the Dapp's state. This\r\n      // way we can indicate that we are waiting for it to be mined.\r\n      const tx = await this._simpleToken.transfer(to, amount)\r\n      this.setState({ txBeingSent: tx.hash })\r\n\r\n      // We use .wait() to wait for the transaction to be mined. This method\r\n      // returns the transaction's receipt.\r\n      const receipt = await tx.wait()\r\n\r\n      // The receipt, contains a status flag, which is 0 to indicate an error.\r\n      if (receipt.status === 0) {\r\n        // We can't know the exact error that make the transaction fail once it\r\n        // was mined, so we throw this generic one.\r\n        throw new Error('Transaction failed')\r\n      }\r\n\r\n      // If we got here, the transaction was successful, so you may want to\r\n      // update your state. Here, we update the user's balance.\r\n      await this._updateBalance()\r\n    } catch (error) {\r\n      // We check the error code to see if this error was produced because the\r\n      // user rejected a tx. If that's the case, we do nothing.\r\n      if (error.code === ERROR_CODE_TX_REJECTED_BY_USER) {\r\n        return\r\n      }\r\n\r\n      // Other errors are logged and stored in the Dapp's state. This is used to\r\n      // show them to the user, and for debugging.\r\n      console.error(error)\r\n      this.setState({ transactionError: error })\r\n    } finally {\r\n      // If we leave the try/catch, we aren't sending a tx anymore, so we clear\r\n      // this part of the state.\r\n      this.setState({ txBeingSent: undefined })\r\n    }\r\n  }\r\n\r\n  // This method just clears part of the state.\r\n  _dismissTransactionError() {\r\n    this.setState({ transactionError: undefined })\r\n  }\r\n\r\n  // This method just clears part of the state.\r\n  _dismissNetworkError() {\r\n    this.setState({ networkError: undefined })\r\n  }\r\n\r\n  // This is an utility method that turns an RPC error into a human readable\r\n  // message.\r\n  _getRpcErrorMessage(error) {\r\n    if (error.data) {\r\n      return error.data.message\r\n    }\r\n\r\n    return error.message\r\n  }\r\n\r\n  // This method resets the state\r\n  _resetState() {\r\n    this.setState(this.initialState)\r\n  }\r\n\r\n  // This method checks if Metamask selected network is Localhost:8545\r\n  _checkNetwork() {\r\n    if (window.ethereum.networkVersion === HARDHAT_NETWORK_ID) {\r\n      return true\r\n    }\r\n\r\n    this.setState({\r\n      networkError: 'Please connect Metamask to goerli',\r\n    })\r\n\r\n    return false\r\n  }\r\n\r\n  async _deployContract() {\r\n    this.setState({ deployBegin: true })\r\n    let simpleTokenContractFactory = new ethers.ContractFactory(\r\n      simpleTokenArtifact.abi,\r\n      simpleTokenArtifact.bytecode,\r\n      this._provider.getSigner(0)\r\n    )\r\n\r\n    let simpleTokenContract = await simpleTokenContractFactory.deploy(\r\n      'hello',\r\n      'Dapp',\r\n      1,\r\n      100000000\r\n    )\r\n    await simpleTokenContract.deployed()\r\n\r\n    simpleTokenContractAddress = simpleTokenContract.address\r\n    await this._intializeEthers()\r\n\r\n    this.setState({ deployBegin: undefined })\r\n  }\r\n}"],"mappings":";AAAA,OAAOA,KAAK,MAAM,OAAO;AAEzB,SAASC,MAAM,QAAQ,QAAQ;AAG/B,OAAOC,mBAAmB,MAAM,+BAA+B;AAC/D,OAAOC,eAAe,MAAM,oCAAoC;AAChE,OAAOC,eAAe,MAAM,4BAA4B;AAGxD,SAASC,gBAAgB,QAAQ,oBAAoB;AACrD,SAASC,aAAa,QAAQ,iBAAiB;AAC/C,SAASC,OAAO,QAAQ,WAAW;AACnC,SAASC,QAAQ,QAAQ,YAAY;AACrC,SAASC,uBAAuB,QAAQ,2BAA2B;AACnE,SAASC,4BAA4B,QAAQ,gCAAgC;AAC7E,SAASC,eAAe,QAAQ,mBAAmB;AAAA,SAAAC,MAAA,IAAAC,OAAA;AAEnD,MAAMC,kBAAkB,GAAG,OAAO;AAElC,MAAMC,8BAA8B,GAAG,IAAI;AAE3C,IAAIC,0BAA0B,GAAGb,eAAe,CAACA,eAAe;AAEhE,MAAMc,gBAAgB,GAAGb,eAAe,CAACc,QAAQ;AAEjD,OAAO,MAAMC,IAAI,SAASnB,KAAK,CAACoB,SAAS,CAAC;EACxCC,WAAWA,CAACC,KAAK,EAAE;IACjB,KAAK,CAACA,KAAK,CAAC;;IAEZ;IACA;IACA,IAAI,CAACC,YAAY,GAAG;MAClB;MACAC,SAAS,EAAEC,SAAS;MACpB;MACAC,eAAe,EAAED,SAAS;MAC1BE,OAAO,EAAEF,SAAS;MAClB;MACAG,WAAW,EAAEH,SAAS;MACtBI,WAAW,EAAEJ,SAAS;MACtBK,gBAAgB,EAAEL,SAAS;MAC3BM,YAAY,EAAEN,SAAS;MACvBO,QAAQ,EAAEP;IACZ,CAAC;IAED,IAAI,CAACQ,KAAK,GAAG,IAAI,CAACV,YAAY;EAChC;EAEAW,MAAMA,CAAA,EAAG;IACP;IACA;IACA,IAAIC,MAAM,CAACC,QAAQ,KAAKX,SAAS,EAAE;MACjC,oBAAOZ,OAAA,CAACR,gBAAgB;QAAAgC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAE,CAAC;IAC7B;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI,CAAC,IAAI,CAACP,KAAK,CAACP,eAAe,EAAE;MAC/B,oBACEb,OAAA,CAACP,aAAa;QACZmC,aAAa,EAAEA,CAAA,KAAM,IAAI,CAACC,cAAc,CAAC,CAAE;QAC3CX,YAAY,EAAE,IAAI,CAACE,KAAK,CAACF,YAAa;QACtCY,OAAO,EAAEA,CAAA,KAAM,IAAI,CAACC,oBAAoB,CAAC;MAAE;QAAAP,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAC5C,CAAC;IAEN;;IAEA;IACA;IACA,IAAI,CAAC,IAAI,CAACP,KAAK,CAACT,SAAS,IAAI,CAAC,IAAI,CAACS,KAAK,CAACN,OAAO,EAAE;MAChD,oBAAOd,OAAA,CAACN,OAAO;QAAA8B,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAE,CAAC;IACpB;;IAEA;IACA,oBACE3B,OAAA;MAAKgC,SAAS,EAAC,eAAe;MAAAC,QAAA,gBAC5BjC,OAAA;QAAKgC,SAAS,EAAC,KAAK;QAAAC,QAAA,eAClBjC,OAAA;UAAKgC,SAAS,EAAC,QAAQ;UAAAC,QAAA,gBACrBjC,OAAA;YAAAiC,QAAA,GACG,IAAI,CAACb,KAAK,CAACT,SAAS,CAACuB,IAAI,EAAC,IAAE,EAAC,IAAI,CAACd,KAAK,CAACT,SAAS,CAACwB,MAAM,EAAC,GAC5D;UAAA;YAAAX,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OAAI,CAAC,eACL3B,OAAA;YAAAiC,QAAA,GAAG,UACO,eAAAjC,OAAA;cAAAiC,QAAA,EAAI,IAAI,CAACb,KAAK,CAACP;YAAe;cAAAW,QAAA,EAAAC,YAAA;cAAAC,UAAA;cAAAC,YAAA;YAAA,OAAI,CAAC,cAAU,EAAC,GAAG,eACzD3B,OAAA;cAAAiC,QAAA,GAEG7C,MAAM,CAACgD,KAAK,CAACC,WAAW,CAAC,IAAI,CAACjB,KAAK,CAACN,OAAO,EAAE,IAAI,CAACM,KAAK,CAACD,QAAQ,CAAC,EAAC,GAAC,EAAC,IAAI,CAACC,KAAK,CAACT,SAAS,CAACwB,MAAM;YAAA;cAAAX,QAAA,EAAAC,YAAA;cAAAC,UAAA;cAAAC,YAAA;YAAA,OAC/F,CAAC,KAEN;UAAA;YAAAH,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OAAG,CAAC;QAAA;UAAAH,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OACD;MAAC;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACH,CAAC,eAEN3B,OAAA;QAAAwB,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAK,CAAC,eAEN3B,OAAA;QAAKgC,SAAS,EAAC,KAAK;QAAAC,QAAA,eAClBjC,OAAA;UAAKgC,SAAS,EAAC,QAAQ;UAAAC,QAAA,GAMpB,IAAI,CAACb,KAAK,CAACL,WAAW,iBACrBf,OAAA,CAACH,4BAA4B;YAACyC,MAAM,EAAE,IAAI,CAAClB,KAAK,CAACL;UAAY;YAAAS,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OAAE,CAChE,EAMA,IAAI,CAACP,KAAK,CAACH,gBAAgB,iBAC1BjB,OAAA,CAACJ,uBAAuB;YACtB2C,OAAO,EAAE,IAAI,CAACC,mBAAmB,CAAC,IAAI,CAACpB,KAAK,CAACH,gBAAgB,CAAE;YAC/Da,OAAO,EAAEA,CAAA,KAAM,IAAI,CAACW,wBAAwB,CAAC;UAAE;YAAAjB,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OAChD,CACF;QAAA;UAAAH,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OACE;MAAC;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACH,CAAC,eAEN3B,OAAA;QAAKgC,SAAS,EAAC,KAAK;QAAAC,QAAA,eAClBjC,OAAA;UAAKgC,SAAS,EAAC,QAAQ;UAAAC,QAAA,GAIpB,IAAI,CAACb,KAAK,CAACN,OAAO,CAAC4B,EAAE,CAAC,CAAC,CAAC,iBACvB1C,OAAA,CAACF,eAAe;YAAC6C,cAAc,EAAEA,CAAA,KAAM,IAAI,CAACC,eAAe,CAAC;UAAE;YAAApB,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OAAE,CACjE,EACA,IAAI,CAACP,KAAK,CAACJ,WAAW,iBAAIhB,OAAA,CAACN,OAAO;YAAA8B,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OAAE,CAAC,EAQrC,IAAI,CAACP,KAAK,CAACN,OAAO,CAAC+B,EAAE,CAAC,CAAC,CAAC,iBACvB7C,OAAA,CAACL,QAAQ;YACPmD,cAAc,EAAEA,CAACC,EAAE,EAAEC,MAAM;YACzB;YACA,IAAI,CAACC,eAAe,CAACF,EAAE,EAAE3D,MAAM,CAACgD,KAAK,CAACc,UAAU,CAACF,MAAM,EAAE,IAAI,CAAC5B,KAAK,CAACD,QAAQ,CAAC;UAC9E;YAAAK,QAAA,EAAAC,YAAA;YAAAC,UAAA;YAAAC,YAAA;UAAA,OACF,CACF;QAAA;UAAAH,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OACE;MAAC;QAAAH,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OACH,CAAC;IAAA;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACH,CAAC;EAEV;EAEAwB,oBAAoBA,CAAA,EAAG;IACrB;IACA;IACA,IAAI,CAACC,gBAAgB,CAAC,CAAC;EACzB;EAEA,MAAMvB,cAAcA,CAAA,EAAG;IACrB;IACA;;IAEA;IACA;IACA,MAAM,CAAChB,eAAe,CAAC,GAAG,MAAMS,MAAM,CAACC,QAAQ,CAAC8B,OAAO,CAAC;MAAEC,MAAM,EAAE;IAAsB,CAAC,CAAC;;IAE1F;;IAEA;IACA,IAAI,CAAC,IAAI,CAACC,aAAa,CAAC,CAAC,EAAE;MACzB;IACF;IAEA,IAAI,CAACC,WAAW,CAAC3C,eAAe,CAAC;;IAEjC;IACAS,MAAM,CAACC,QAAQ,CAACkC,EAAE,CAAC,iBAAiB,EAAE,CAAC,CAACC,UAAU,CAAC,KAAK;MACtD,IAAI,CAACN,gBAAgB,CAAC,CAAC;MACvB;MACA;MACA;MACA;MACA,IAAIM,UAAU,KAAK9C,SAAS,EAAE;QAC5B,OAAO,IAAI,CAAC+C,WAAW,CAAC,CAAC;MAC3B;MAEA,IAAI,CAACH,WAAW,CAACE,UAAU,CAAC;IAC9B,CAAC,CAAC;;IAEF;IACApC,MAAM,CAACC,QAAQ,CAACkC,EAAE,CAAC,cAAc,EAAE,CAAC,CAACG,QAAQ,CAAC,KAAK;MACjD,IAAI,CAACR,gBAAgB,CAAC,CAAC;MACvB,IAAI,CAACO,WAAW,CAAC,CAAC;IACpB,CAAC,CAAC;EACJ;EAEAH,WAAWA,CAACK,WAAW,EAAE;IACvB;;IAEA;IACA,IAAI,CAACC,QAAQ,CAAC;MACZjD,eAAe,EAAEgD;IACnB,CAAC,CAAC;;IAEF;IACA;;IAEA;IACA;IACA,IAAI,CAACE,gBAAgB,CAAC,CAAC;IACvB,IAAI,CAACC,aAAa,CAAC,CAAC;IACpB,IAAI,CAACC,iBAAiB,CAAC,CAAC;EAC1B;EAEA,MAAMF,gBAAgBA,CAAA,EAAG;IACvB;IACA,IAAI,CAACG,SAAS,GAAG,IAAI9E,MAAM,CAAC+E,SAAS,CAACC,YAAY,CAAC9C,MAAM,CAACC,QAAQ,CAAC;;IAEnE;IACA;IACA,IAAI,CAAC8C,YAAY,GAAG,IAAIjF,MAAM,CAACkF,QAAQ,CACrCnE,0BAA0B,EAC1Bd,mBAAmB,CAACkF,GAAG,EACvB,IAAI,CAACL,SAAS,CAACM,SAAS,CAAC,CAAC,CAC5B,CAAC;IACD,IAAI,CAACV,QAAQ,CAAC;MAAC3C,QAAQ,EAAE,MAAM,IAAI,CAACkD,YAAY,CAAClD,QAAQ,CAAC;IAAC,CAAC,CAAC;EAC/D;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA8C,iBAAiBA,CAAA,EAAG;IAClB,IAAI,CAACQ,iBAAiB,GAAGC,WAAW,CAAC,MAAM,IAAI,CAACC,cAAc,CAAC,CAAC,EAAE,IAAI,CAAC;;IAEvE;IACA,IAAI,CAACA,cAAc,CAAC,CAAC;EACvB;EAEAvB,gBAAgBA,CAAA,EAAG;IACjBwB,aAAa,CAAC,IAAI,CAACH,iBAAiB,CAAC;IACrC,IAAI,CAACA,iBAAiB,GAAG7D,SAAS;EACpC;;EAEA;EACA;EACA,MAAMoD,aAAaA,CAAA,EAAG;IACpB,MAAM9B,IAAI,GAAG,MAAM,IAAI,CAACmC,YAAY,CAACnC,IAAI,CAAC,CAAC;IAC3C,MAAMC,MAAM,GAAG,MAAM,IAAI,CAACkC,YAAY,CAAClC,MAAM,CAAC,CAAC;IAE/C,IAAI,CAAC2B,QAAQ,CAAC;MAAEnD,SAAS,EAAE;QAAEuB,IAAI;QAAEC;MAAO;IAAE,CAAC,CAAC;EAChD;EAEA,MAAMwC,cAAcA,CAAA,EAAG;IACrB,MAAM7D,OAAO,GAAG,MAAM,IAAI,CAACuD,YAAY,CAACQ,SAAS,CAC/C,IAAI,CAACzD,KAAK,CAACP,eACb,CAAC;IACD,IAAI,CAACiD,QAAQ,CAAC;MAAEhD;IAAQ,CAAC,CAAC;EAC5B;;EAEA;EACA;EACA;EACA,MAAMmC,eAAeA,CAACF,EAAE,EAAEC,MAAM,EAAE;IAChC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA,IAAI;MACF;MACA;MACA;MACA,IAAI,CAACP,wBAAwB,CAAC,CAAC;;MAE/B;MACA;MACA,MAAMqC,EAAE,GAAG,MAAM,IAAI,CAACT,YAAY,CAACU,QAAQ,CAAChC,EAAE,EAAEC,MAAM,CAAC;MACvD,IAAI,CAACc,QAAQ,CAAC;QAAE/C,WAAW,EAAE+D,EAAE,CAACE;MAAK,CAAC,CAAC;;MAEvC;MACA;MACA,MAAMC,OAAO,GAAG,MAAMH,EAAE,CAACI,IAAI,CAAC,CAAC;;MAE/B;MACA,IAAID,OAAO,CAACE,MAAM,KAAK,CAAC,EAAE;QACxB;QACA;QACA,MAAM,IAAIC,KAAK,CAAC,oBAAoB,CAAC;MACvC;;MAEA;MACA;MACA,MAAM,IAAI,CAACT,cAAc,CAAC,CAAC;IAC7B,CAAC,CAAC,OAAOU,KAAK,EAAE;MACd;MACA;MACA,IAAIA,KAAK,CAACC,IAAI,KAAKpF,8BAA8B,EAAE;QACjD;MACF;;MAEA;MACA;MACAqF,OAAO,CAACF,KAAK,CAACA,KAAK,CAAC;MACpB,IAAI,CAACvB,QAAQ,CAAC;QAAE7C,gBAAgB,EAAEoE;MAAM,CAAC,CAAC;IAC5C,CAAC,SAAS;MACR;MACA;MACA,IAAI,CAACvB,QAAQ,CAAC;QAAE/C,WAAW,EAAEH;MAAU,CAAC,CAAC;IAC3C;EACF;;EAEA;EACA6B,wBAAwBA,CAAA,EAAG;IACzB,IAAI,CAACqB,QAAQ,CAAC;MAAE7C,gBAAgB,EAAEL;IAAU,CAAC,CAAC;EAChD;;EAEA;EACAmB,oBAAoBA,CAAA,EAAG;IACrB,IAAI,CAAC+B,QAAQ,CAAC;MAAE5C,YAAY,EAAEN;IAAU,CAAC,CAAC;EAC5C;;EAEA;EACA;EACA4B,mBAAmBA,CAAC6C,KAAK,EAAE;IACzB,IAAIA,KAAK,CAACG,IAAI,EAAE;MACd,OAAOH,KAAK,CAACG,IAAI,CAACjD,OAAO;IAC3B;IAEA,OAAO8C,KAAK,CAAC9C,OAAO;EACtB;;EAEA;EACAoB,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACG,QAAQ,CAAC,IAAI,CAACpD,YAAY,CAAC;EAClC;;EAEA;EACA6C,aAAaA,CAAA,EAAG;IACd,IAAIjC,MAAM,CAACC,QAAQ,CAACkE,cAAc,KAAKxF,kBAAkB,EAAE;MACzD,OAAO,IAAI;IACb;IAEA,IAAI,CAAC6D,QAAQ,CAAC;MACZ5C,YAAY,EAAE;IAChB,CAAC,CAAC;IAEF,OAAO,KAAK;EACd;EAEA,MAAM0B,eAAeA,CAAA,EAAG;IACtB,IAAI,CAACkB,QAAQ,CAAC;MAAE9C,WAAW,EAAE;IAAK,CAAC,CAAC;IACpC,IAAI0E,0BAA0B,GAAG,IAAItG,MAAM,CAACuG,eAAe,CACzDtG,mBAAmB,CAACkF,GAAG,EACvBlF,mBAAmB,CAACuG,QAAQ,EAC5B,IAAI,CAAC1B,SAAS,CAACM,SAAS,CAAC,CAAC,CAC5B,CAAC;IAED,IAAIqB,mBAAmB,GAAG,MAAMH,0BAA0B,CAACI,MAAM,CAC/D,OAAO,EACP,MAAM,EACN,CAAC,EACD,SACF,CAAC;IACD,MAAMD,mBAAmB,CAACE,QAAQ,CAAC,CAAC;IAEpC5F,0BAA0B,GAAG0F,mBAAmB,CAACG,OAAO;IACxD,MAAM,IAAI,CAACjC,gBAAgB,CAAC,CAAC;IAE7B,IAAI,CAACD,QAAQ,CAAC;MAAE9C,WAAW,EAAEJ;IAAU,CAAC,CAAC;EAC3C;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}